<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Cascata POP - Prototype</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; touch-action:none; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
/**
 * PROTOTIPO "CASCATA POP"
 * - Sfondo immagine (NON modificato) + oggetti che scendono in 5 corsie
 * - Player piccolo in basso: selezionabile via tasti 1/2/3 (bimbo/bimba/coniglio)
 * - Controlli: trascina col dito per spostarti di corsia (o frecce sx/dx)
 * - Buoni: punti, Cattivi: perdi vita
 */

// ====== CONFIG BASE ======
const BG_SRC = "bg.png";      // <-- metti il tuo sfondo qui (stessa cartella)
const LANES = 5;

const cfg = {
  // prospettiva corsie (convergenza verso l'alto)
  topY: 0.20,           // dove "nascono" gli oggetti (parte bianca in alto)
  bottomY: 0.90,        // dove sta il player
  topSpread: 0.18,      // quanto sono "vicine" le corsie in alto (0.10..0.25)
  bottomLeft: 0.12,     // area pavimento in basso
  bottomRight: 0.88,

  // gameplay
  spawnEveryMs: 650,
  baseSpeed: 0.42,      // più alto = più veloce
  speedRamp: 0.00006,   // aumenta nel tempo (difficoltà)
  goodChance: 0.62,     // % buoni
  lives: 3,

  // hit window vicino al player
  hitT: 0.93,
  hitWindow: 0.055,

  // debug
  debugLanes: false
};

// ====== CANVAS SETUP ======
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

function resize() {
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  canvas.width  = Math.floor(innerWidth * dpr);
  canvas.height = Math.floor(innerHeight * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize", resize);
resize();

// ====== UTILS ======
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const easeIn = (t)=>t*t;

function laneX(laneIndex, tNorm, w) {
  // tNorm: 0 in alto -> 1 in basso
  const r = (LANES===1) ? 0.5 : laneIndex/(LANES-1);
  const topCenter = 0.5;
  const topLeft  = topCenter - cfg.topSpread/2;
  const topRight = topCenter + cfg.topSpread/2;

  const xTop = lerp(topLeft*w, topRight*w, r);
  const xBot = lerp(cfg.bottomLeft*w, cfg.bottomRight*w, r);
  return lerp(xTop, xBot, tNorm);
}

function yFromT(tNorm, h) {
  // spingo un po' con easing per dare feeling "vengono verso di te"
  const t = easeIn(clamp(tNorm, 0, 1));
  return lerp(cfg.topY*h, cfg.bottomY*h, t);
}

function scaleFromT(tNorm) {
  // piccolo in alto, grande in basso
  return lerp(0.35, 1.05, clamp(tNorm,0,1));
}

function nearestLaneAtBottom(x, w) {
  let best = 0, bestD = Infinity;
  for (let i=0;i<LANES;i++) {
    const lx = laneX(i, 1, w);
    const d = Math.abs(x - lx);
    if (d < bestD) { bestD = d; best = i; }
  }
  return best;
}

// ====== ASSETS ======
const bgImg = new Image();
bgImg.src = BG_SRC;
let bgReady = false;
bgImg.onload = ()=> bgReady = true;
bgImg.onerror = ()=> {
  // se non trova bg.png, almeno non crasha
  bgReady = false;
  console.warn("Sfondo non trovato. Metti bg.png nella stessa cartella di index.html");
};

// ====== GAME STATE ======
let started = false;
let lastTs = 0;
let elapsed = 0;

const state = {
  score: 0,
  lives: cfg.lives,
  playerLane: 2,
  playerSkin: "bunny", // "boy" | "girl" | "bunny"
  obstacles: [],
  nextSpawn: 0
};

function resetGame() {
  state.score = 0;
  state.lives = cfg.lives;
  state.playerLane = 2;
  state.obstacles = [];
  elapsed = 0;
  lastTs = 0;
  state.nextSpawn = 0;
}

// ====== DRAW: PLAYER & OBSTACLES (semplici, senza cambiare sfondo) ======
function drawKawaiiFace(x, y, r) {
  // occhi
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.10, r*0.10, 0, Math.PI*2); ctx.fill();
  // puntini luce
  ctx.fillStyle = "rgba(255,255,255,0.9)";
  ctx.beginPath(); ctx.arc(x - r*0.32, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.38, y - r*0.14, r*0.04, 0, Math.PI*2); ctx.fill();
  // bocca
  ctx.strokeStyle = "rgba(0,0,0,0.75)";
  ctx.lineWidth = Math.max(1, r*0.06);
  ctx.beginPath();
  ctx.arc(x, y + r*0.08, r*0.18, 0.15*Math.PI, 0.85*Math.PI);
  ctx.stroke();
}

function drawPlayer(x, y, s, skin) {
  const r = 18 * s;
  ctx.save();
  ctx.translate(x, y);

  if (skin === "boy" || skin === "girl") {
    // testolina + cuffie
    ctx.fillStyle = "rgba(255,240,220,0.95)";
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

    // capelli
    ctx.fillStyle = (skin==="girl") ? "rgba(230,200,80,0.95)" : "rgba(120,70,30,0.95)";
    ctx.beginPath();
    ctx.arc(0, -r*0.2, r*1.05, Math.PI, 0);
    ctx.fill();

    // cuffie
    ctx.fillStyle = "rgba(60,220,140,0.95)";
    ctx.beginPath(); ctx.arc(-r*1.05, 0, r*0.35, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*1.05, 0, r*0.35, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = "rgba(30,30,30,0.7)";
    ctx.lineWidth = Math.max(2, r*0.12);
    ctx.beginPath(); ctx.arc(0, -r*0.65, r*1.1, Math.PI*1.05, Math.PI*1.95); ctx.stroke();

    drawKawaiiFace(0, 2, r*0.95);
  } else {
    // coniglio
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    // testa
    ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
    // orecchie
    ctx.beginPath(); ctx.ellipse(-r*0.55, -r*1.25, r*0.35, r*0.75, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( r*0.55, -r*1.25, r*0.35, r*0.75,  0.15, 0, Math.PI*2); ctx.fill();
    // interno orecchie
    ctx.fillStyle = "rgba(255,170,190,0.85)";
    ctx.beginPath(); ctx.ellipse(-r*0.55, -r*1.22, r*0.18, r*0.55, -0.15, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse( r*0.55, -r*1.22, r*0.18, r*0.55,  0.15, 0, Math.PI*2); ctx.fill();

    // cuffie
    ctx.fillStyle = "rgba(80,180,255,0.95)";
    ctx.beginPath(); ctx.arc(-r*1.00, 0, r*0.32, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc( r*1.00, 0, r*0.32, 0, Math.PI*2); ctx.fill();

    drawKawaiiFace(0, 2, r*0.95);
  }

  ctx.restore();
}

function drawGood(x, y, s) {
  // "buono" = pallina dolce con faccia
  const r = 22 * s;
  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "rgba(255,120,170,0.55)";
  ctx.beginPath(); ctx.arc(x - r*0.5, y + r*0.15, r*0.22, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + r*0.5, y + r*0.15, r*0.22, 0, Math.PI*2); ctx.fill();
  drawKawaiiFace(x, y, r);
}

function drawBad(x, y, s) {
  // "cattivo" = cubo arrabbiato (poliziotto/maestra OK), ma qui lo facciamo neutro senza armi
  const size = 44 * s;
  const r = 10 * s;
  ctx.fillStyle = "rgba(255,200,70,0.95)";
  roundRect(x - size/2, y - size/2, size, size, r);
  ctx.fill();

  // cappello
  ctx.fillStyle = "rgba(20,20,20,0.85)";
  roundRect(x - size*0.35, y - size*0.68, size*0.7, size*0.22, 6*s);
  ctx.fill();

  // faccia arrabbiata
  ctx.strokeStyle = "rgba(0,0,0,0.8)";
  ctx.lineWidth = Math.max(2, 3*s);

  // sopracciglia
  ctx.beginPath();
  ctx.moveTo(x - size*0.22, y - size*0.12);
  ctx.lineTo(x - size*0.02, y - size*0.22);
  ctx.moveTo(x + size*0.22, y - size*0.12);
  ctx.lineTo(x + size*0.02, y - size*0.22);
  ctx.stroke();

  // occhi
  ctx.fillStyle = "rgba(0,0,0,0.85)";
  ctx.beginPath(); ctx.arc(x - size*0.16, y - size*0.02, 4*s, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x + size*0.16, y - size*0.02, 4*s, 0, Math.PI*2); ctx.fill();

  // bocca
  ctx.strokeStyle = "rgba(120,0,0,0.85)";
  ctx.lineWidth = Math.max(2, 4*s);
  ctx.beginPath();
  ctx.moveTo(x - size*0.12, y + size*0.15);
  ctx.lineTo(x + size*0.12, y + size*0.15);
  ctx.stroke();

  // megafono (solo simbolico, no arma)
  ctx.fillStyle = "rgba(40,170,255,0.9)";
  ctx.beginPath();
  ctx.moveTo(x + size*0.30, y - size*0.05);
  ctx.lineTo(x + size*0.55, y - size*0.16);
  ctx.lineTo(x + size*0.55, y + size*0.06);
  ctx.closePath();
  ctx.fill();
}

function roundRect(x, y, w, h, r) {
  r = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
}

// ====== SPAWN & UPDATE ======
function spawnObstacle() {
  const lane = Math.floor(Math.random() * LANES);
  const isGood = Math.random() < cfg.goodChance;
  state.obstacles.push({
    lane,
    t: 0,              // 0 top -> 1 bottom
    kind: isGood ? "good" : "bad",
    taken: false
  });
}

function update(dt, w, h) {
  elapsed += dt;

  // spawn
  state.nextSpawn -= dt*1000;
  if (state.nextSpawn <= 0) {
    spawnObstacle();
    // un minimo di variabilità
    const jitter = (Math.random()*140 - 70);
    state.nextSpawn = Math.max(260, cfg.spawnEveryMs + jitter);
  }

  const speed = cfg.baseSpeed + elapsed * cfg.speedRamp;

  // move obstacles
  for (const o of state.obstacles) {
    o.t += dt * speed;
  }

  // collision vicino al player
  for (const o of state.obstacles) {
    if (o.taken) continue;
    const near = Math.abs(o.t - cfg.hitT) <= cfg.hitWindow;
    if (!near) continue;

    if (o.lane === state.playerLane) {
      o.taken = true;
      if (o.kind === "good") {
        state.score += 10;
      } else {
        state.lives -= 1;
        if (state.lives <= 0) {
          started = false; // game over
        }
      }
    }
  }

  // cleanup
  state.obstacles = state.obstacles.filter(o => o.t < 1.15 && !o.taken);
}

// ====== RENDER ======
function drawBgCover() {
  const w = innerWidth, h = innerHeight;
  if (!bgReady) {
    // fallback semplice
    ctx.fillStyle = "#140018";
    ctx.fillRect(0,0,w,h);
    return;
  }

  const iw = bgImg.naturalWidth, ih = bgImg.naturalHeight;
  const s = Math.max(w/iw, h/ih);
  const dw = iw*s, dh = ih*s;
  const dx = (w - dw)/2;
  const dy = (h - dh)/2;
  ctx.drawImage(bgImg, dx, dy, dw, dh);
}

function drawHud() {
  // niente UI invasiva: solo minimal in alto a sinistra
  ctx.save();
  ctx.globalAlpha = 0.75;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.fillRect(10, 10, 180, 58);
  ctx.globalAlpha = 1;
  ctx.fillStyle = "white";
  ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto";
  ctx.fillText(`Punti: ${state.score}`, 22, 34);
  ctx.fillText(`Vite: ${"❤".repeat(Math.max(0,state.lives))}`, 22, 54);
  ctx.restore();
}

function drawLanesDebug(w, h) {
  const yTop = cfg.topY*h;
  const yBot = cfg.bottomY*h;
  ctx.save();
  ctx.strokeStyle = "rgba(255,255,255,0.25)";
  ctx.lineWidth = 2;
  for (let i=0;i<LANES;i++) {
    const x1 = laneX(i, 0, w);
    const x2 = laneX(i, 1, w);
    ctx.beginPath();
    ctx.moveTo(x1, yTop);
    ctx.lineTo(x2, yBot);
    ctx.stroke();
  }
  ctx.restore();
}

function render() {
  const w = innerWidth, h = innerHeight;
  ctx.clearRect(0,0,w,h);

  // sfondo (immutato)
  drawBgCover();

  if (cfg.debugLanes) drawLanesDebug(w,h);

  // ostacoli
  for (const o of state.obstacles) {
    const x = laneX(o.lane, o.t, w);
    const y = yFromT(o.t, h);
    const s = scaleFromT(o.t);
    if (o.kind === "good") drawGood(x, y, s);
    else drawBad(x, y, s);
  }

  // player
  const px = laneX(state.playerLane, 1, w);
  const py = yFromT(1, h);
  drawPlayer(px, py, 1.0, state.playerSkin);

  drawHud();

  if (!started) {
    // "tap to start"
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.fillRect(0,0,w,h);
    ctx.fillStyle = "white";
    ctx.font = "22px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.textAlign = "center";
    ctx.fillText(state.lives<=0 ? "GAME OVER - Tocca per ricominciare" : "TOCCA PER INIZIARE", w/2, h*0.45);
    ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto";
    ctx.fillText("Trascina per cambiare corsia • Tasti 1/2/3 per skin", w/2, h*0.45 + 28);
    ctx.restore();
  }
}

// ====== MAIN LOOP ======
function loop(ts) {
  if (!lastTs) lastTs = ts;
  const dt = Math.min(0.033, (ts - lastTs)/1000);
  lastTs = ts;

  if (started) update(dt, innerWidth, innerHeight);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// ====== INPUT ======
let pointerDown = false;

function startOrRestart() {
  if (state.lives <= 0) resetGame();
  started = true;
}

canvas.addEventListener("pointerdown", (e) => {
  pointerDown = true;
  canvas.setPointerCapture?.(e.pointerId);
  if (!started) startOrRestart();
  // spostamento immediato
  const x = e.clientX;
  state.playerLane = nearestLaneAtBottom(x, innerWidth);
});

canvas.addEventListener("pointermove", (e) => {
  if (!pointerDown || !started) return;
  const x = e.clientX;
  state.playerLane = nearestLaneAtBottom(x, innerWidth);
});

canvas.addEventListener("pointerup", () => pointerDown = false);
canvas.addEventListener("pointercancel", () => pointerDown = false);

// tastiera (solo test)
addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft") state.playerLane = clamp(state.playerLane - 1, 0, LANES-1);
  if (e.key === "ArrowRight") state.playerLane = clamp(state.playerLane + 1, 0, LANES-1);
  if (e.key === "1") state.playerSkin = "boy";
  if (e.key === "2") state.playerSkin = "girl";
  if (e.key === "3") state.playerSkin = "bunny";
  if (e.key.toLowerCase() === "r") { resetGame(); started = false; }
});
</script>
</body>
</html>
