<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Porcellino Jump</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#fff; overflow:hidden; touch-action:manipulation; }
    canvas { display:block; width:100vw; height:100vh; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  // ---------- Canvas ----------
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  // polyfill roundRect (se manca)
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    };
  }

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener("resize", resize, { passive:true });
  resize();

  // ---------- ASSETS (metti i file in /assets) ----------
  const ASSETS = {
    bgSrc:    "assets/bg.jpg",     // oppure assets/bg.png
    bongSrc:  "assets/bong.png",
    cuffsSrc: "assets/cuffs.png",
  };

  // ---------- Image Loader ----------
  function loadImage(src) {
    return new Promise((resolve) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null);
      img.src = src;
    });
  }

  const IMAGES = { bg:null, bong:null, cuffs:null };

  // cover draw
  function drawImageCover(img) {
    const w = innerWidth, h = innerHeight;
    const iw = img.naturalWidth || img.width;
    const ih = img.naturalHeight || img.height;
    const s = Math.max(w / iw, h / ih);
    const dw = iw * s;
    const dh = ih * s;
    const dx = (w - dw) / 2;
    const dy = (h - dh) / 2;
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  // ---------- Audio (mini) ----------
  let audioCtx = null;
  function beep(freq=440, dur=0.05, type="sine", gain=0.03) {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = gain;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    } catch(e) {}
  }

  // ---------- World ----------
  const W = () => innerWidth;
  const H = () => innerHeight;

  const world = {
    state: "ready", // ready | play | over
    t: 0,
    score: 0,
    best: Number(localStorage.getItem("pig_best") || 0),
    speed: 320,
    spawnMin: 0.85,
    spawnMax: 1.55,
    nextSpawn: 1.0,
    groundY: () => Math.round(H()*0.78),

    // buchi
    holes: [],
    nextHoleX: 0,
  };

  // ---------- Style helpers (doodle) ----------
  function doodleStroke() {
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H()) * 0.0045));
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.strokeStyle = "#000";
    ctx.fillStyle = "#fff";
  }

  function drawHeart(x,y,s=10) {
    doodleStroke();
    ctx.save();
    ctx.translate(x,y);
    ctx.beginPath();
    ctx.moveTo(0, -s*0.2);
    ctx.bezierCurveTo(-s*0.6, -s*0.9, -s*1.2, -s*0.1, 0, s*0.7);
    ctx.bezierCurveTo(s*1.2, -s*0.1, s*0.6, -s*0.9, 0, -s*0.2);
    ctx.closePath();
    ctx.fillStyle = "#fff";
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  function face(x,y,r) {
    doodleStroke();
    ctx.beginPath(); ctx.arc(x - r*0.35, y - r*0.1, Math.max(1.5, r*0.08), 0, Math.PI*2); ctx.fillStyle="#000"; ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.35, y - r*0.1, Math.max(1.5, r*0.08), 0, Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(2, ctx.lineWidth*0.65);
    ctx.arc(x, y + r*0.12, r*0.28, 0.15*Math.PI, 0.85*Math.PI);
    ctx.stroke();
  }

  // ---------- Pig ----------
  const pig = {
    x: () => Math.round(W()*0.22),
    y: 0,
    vy: 0,
    r: () => Math.round(Math.min(W(),H())*0.055),
    onGround: true,
  };

  function rand(a,b){ return a + Math.random()*(b-a); }

  function reset() {
    world.state = "ready";
    world.t = 0;
    world.score = 0;
    world.speed = 320;
    world.nextSpawn = rand(world.spawnMin, world.spawnMax);
    items.length = 0;

    world.holes.length = 0;
    world.nextHoleX = W() + Math.max(260, W()*0.45);

    pig.y = world.groundY() - pig.r();
    pig.vy = 0;
    pig.onGround = true;
  }

  // ---------- Items (ORA SOLO BONUS) ----------
  const items = [];
  const TYPES = ["bong","cuffs"]; // entrambi BONUS da prendere

  function spawnItem() {
    const r = Math.round(Math.min(W(),H())*0.045);
    const type = Math.random() < 0.55 ? "bong" : "cuffs";

    // in alto (raggiungibile col salto)
    const gy = world.groundY();
    const yMin = gy - r*5.2;
    const yMax = gy - r*2.4;

    items.push({
      type,
      r,
      x: W() + r + 10,
      y: Math.max(r+10, rand(yMin, yMax)),
      vx: -world.speed,
      hit: false,
    });
  }

  // ---- Bubble + icon for bong/cuffs ----
  function drawBubbleWithIcon(x, y, r, img, bubbleFill) {
    doodleStroke();

    // ombra
    ctx.save();
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.arc(x + r*0.10, y + r*0.12, r*1.03, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // bubble
    ctx.fillStyle = bubbleFill;
    ctx.beginPath();
    ctx.arc(x, y, r*1.02, 0, Math.PI*2);
    ctx.fill();
    ctx.strokeStyle = "#000";
    ctx.lineWidth = Math.max(2, ctx.lineWidth*0.65);
    ctx.stroke();

    // highlight
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "#fff";
    ctx.beginPath();
    ctx.arc(x - r*0.35, y - r*0.35, r*0.28, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // icon (contain)
    if (img) {
      const pad = r*0.35;
      const box = r*2 - pad;
      const iw = img.naturalWidth || img.width;
      const ih = img.naturalHeight || img.height;
      const s = Math.min(box / iw, box / ih);
      const dw = iw * s;
      const dh = ih * s;
      ctx.drawImage(img, x - dw/2, y - dh/2, dw, dh);
    } else {
      ctx.fillStyle = "#000";
      ctx.font = `900 ${Math.max(16, r*0.9)}px system-ui, -apple-system, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("★", x, y);
      ctx.textAlign = "left";
      ctx.textBaseline = "alphabetic";
    }
  }

  function drawItem(it) {
    if (it.type === "bong") {
      return drawBubbleWithIcon(it.x, it.y, it.r, IMAGES.bong, "rgba(170, 240, 210, 0.95)");
    }
    return drawBubbleWithIcon(it.x, it.y, it.r, IMAGES.cuffs, "rgba(255, 190, 205, 0.95)");
  }

  // ---------- Buchi ----------
  function groundUnderX(px) {
    for (const h of world.holes) {
      if (px >= h.x && px <= h.x + h.w) return false;
    }
    return true;
  }

  function spawnHole() {
    const base = Math.min(W(), H());
    const wMin = Math.max(80, base*0.12);
    const wMax = Math.max(120, base*0.18);
    const spacingMin = Math.max(260, base*0.35);
    const spacingMax = Math.max(520, base*0.55);

    const w = rand(wMin, wMax);
    const x = W() + 10;

    world.holes.push({ x, w });
    world.nextHoleX = x + w + rand(spacingMin, spacingMax);
  }

  function updateHoles(dt) {
    // spawn schedule in screen-coords (scorre con la velocità)
    if (world.nextHoleX <= W()) spawnHole();
    else world.nextHoleX -= world.speed * dt;

    for (const h of world.holes) h.x -= world.speed * dt;
    for (let i=world.holes.length-1; i>=0; i--) {
      if (world.holes[i].x + world.holes[i].w < -30) world.holes.splice(i,1);
    }
  }

  // ---------- Background + ground ----------
  function drawGroundWithHoles() {
    doodleStroke();
    const gy = world.groundY();
    const holes = world.holes.slice().sort((a,b)=>a.x-b.x);

    // linea terreno a segmenti (con buchi)
    let start = 0;
    ctx.beginPath();
    for (const h of holes) {
      const a = Math.max(0, Math.min(W(), h.x));
      const b = Math.max(0, Math.min(W(), h.x + h.w));
      if (a > start) {
        ctx.moveTo(start, gy);
        ctx.lineTo(a, gy);
      }
      start = Math.max(start, b);
      if (start >= W()) break;
    }
    if (start < W()) {
      ctx.moveTo(start, gy);
      ctx.lineTo(W(), gy);
    }
    ctx.stroke();

    // erba solo su terreno (non dentro i buchi)
    ctx.lineWidth *= 0.7;
    const step = Math.max(24, Math.floor(W()/30));
    for (let x=0; x<=W(); x+=step) {
      if (!groundUnderX(x)) continue;
      ctx.beginPath();
      ctx.moveTo(x, gy);
      ctx.lineTo(x+4, gy-8);
      ctx.stroke();
    }
  }

  function drawBackground() {
    ctx.clearRect(0,0,W(),H());

    // sfondo immagine (se presente)
    if (IMAGES.bg) {
      drawImageCover(IMAGES.bg);
    } else {
      ctx.fillStyle = "#fff";
      ctx.fillRect(0,0,W(),H());
    }

    // nuvolette sopra lo sfondo (come prima)
    doodleStroke();
    const topY = Math.round(H()*0.12);
    for (let i=0;i<6;i++){
      const x = (i/6)*W() + (Math.sin(world.t*0.6+i)*18);
      const y = topY + (Math.cos(world.t*0.5+i)*10);
      const s = 18 + (i%3)*6;
      ctx.beginPath();
      ctx.arc(x, y, s, 0, Math.PI*2);
      ctx.fillStyle="rgba(255,255,255,0.75)";
      ctx.fill();
      ctx.strokeStyle="#000";
      ctx.stroke();
      if (i%2===0) drawHeart(x+s*1.2, y-s*0.6, 8);
    }

    // terreno con buchi
    drawGroundWithHoles();
  }

  function drawPig() {
    doodleStroke();
    const r = pig.r();
    const x = pig.x();
    const y = pig.y;

    // corpo
    ctx.beginPath();
    ctx.ellipse(x, y, r*1.05, r*0.85, 0, 0, Math.PI*2);
    ctx.fillStyle = "#ffd2dd";
    ctx.fill();
    ctx.stroke();

    // orecchie
    ctx.beginPath();
    ctx.ellipse(x - r*0.6, y - r*0.75, r*0.28, r*0.35, -0.4, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();
    ctx.beginPath();
    ctx.ellipse(x + r*0.6, y - r*0.75, r*0.28, r*0.35, 0.4, 0, Math.PI*2);
    ctx.fill(); ctx.stroke();

    // muso
    ctx.beginPath();
    ctx.roundRect(x - r*0.45, y - r*0.12, r*0.9, r*0.55, r*0.22);
    ctx.fillStyle="#fff";
    ctx.fill(); ctx.stroke();

    // narici
    ctx.fillStyle="#000";
    ctx.beginPath(); ctx.arc(x - r*0.18, y + r*0.12, Math.max(2, r*0.07), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.18, y + r*0.12, Math.max(2, r*0.07), 0, Math.PI*2); ctx.fill();

    // occhi+bocca
    ctx.beginPath(); ctx.arc(x - r*0.3, y - r*0.25, Math.max(2, r*0.07), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x + r*0.3, y - r*0.25, Math.max(2, r*0.07), 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle="#000";
    ctx.lineWidth = Math.max(2, ctx.lineWidth*0.6);
    ctx.beginPath();
    ctx.arc(x, y - r*0.05, r*0.22, 0.1*Math.PI, 0.9*Math.PI);
    ctx.stroke();
  }

  // ---------- Collision ----------
  function hit(a, bx, by, br) {
    const dx = a.x - bx;
    const dy = a.y - by;
    const rr = a.r + br;
    return (dx*dx + dy*dy) <= rr*rr;
  }

  // ---------- Input ----------
  function jump() {
    if (world.state === "ready") {
      world.state = "play";
      beep(520, 0.05, "square", 0.02);
      return;
    }
    if (world.state === "over") {
      reset();
      beep(520, 0.05, "square", 0.02);
      return;
    }
    if (world.state !== "play") return;

    if (pig.onGround) {
      pig.vy = -Math.max(520, H()*0.65);
      pig.onGround = false;
      beep(380, 0.05, "sine", 0.03);
    }
  }

  addEventListener("pointerdown", (e) => { e.preventDefault(); jump(); }, { passive:false });
  addEventListener("keydown", (e) => { if (e.code==="Space" || e.code==="ArrowUp") jump(); });

  // ---------- Loop ----------
  let last = performance.now();

  function update(dt) {
    world.t += dt;

    const gy = world.groundY();

    // pig physics
    const g = Math.max(1200, H()*1.6);
    pig.vy += g * dt;
    pig.y += pig.vy * dt;

    const px = pig.x();
    const targetY = gy - pig.r();
    const hasGround = groundUnderX(px);

    // se eri “a terra” ma sotto c'è buco: inizia a cadere
    if (pig.onGround && !hasGround) {
      pig.onGround = false;
      pig.vy = Math.max(0, pig.vy);
    }

    // atterra solo se c'è terreno sotto
    if (pig.y >= targetY && hasGround) {
      pig.y = targetY;
      pig.vy = 0;
      pig.onGround = true;
    }

    // se cadi fuori schermo => game over (solo con buchi)
    if (!pig.onGround && pig.y - pig.r() > H() + 30) {
      world.state = "over";
      beep(120, 0.12, "sawtooth", 0.05);
      world.best = Math.max(world.best, Math.floor(world.score));
      localStorage.setItem("pig_best", String(world.best));
      return;
    }

    if (world.state !== "play") return;

    // difficulty (tutto uguale)
    world.speed = Math.min(520, world.speed + 6*dt);

    // buchi
    updateHoles(dt);

    // spawn bonus
    world.nextSpawn -= dt;
    if (world.nextSpawn <= 0) {
      spawnItem();
      world.nextSpawn = rand(world.spawnMin, world.spawnMax);
    }

    // items move + collision (ORA SOLO BONUS)
    for (const it of items) {
      it.vx = -world.speed;
      it.x += it.vx * dt;

      if (!it.hit) {
        const pigPos = { x: pig.x(), y: pig.y, r: pig.r()*0.9 };
        if (hit(pigPos, it.x, it.y, it.r*0.95)) {
          it.hit = true;
          // bonus punti (cuffs e bong sono entrambi bonus)
          world.score += (it.type === "bong") ? 2 : 1;
          beep(it.type === "bong" ? 740 : 660, 0.06, "triangle", 0.03);
        }
      }
    }

    // cleanup items
    for (let i=items.length-1; i>=0; i--) {
      if (items[i].x < -items[i].r - 40 || items[i].hit) items.splice(i,1);
    }
  }

  function centerText(text, y, scale=1.0) {
    doodleStroke();
    const size = Math.max(20, Math.round(Math.min(W(),H())*0.045*scale));
    ctx.font = `900 ${size}px ui-rounded, system-ui, -apple-system, sans-serif`;
    ctx.textAlign = "center";
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));
    ctx.strokeText(text, W()/2, y);
    ctx.fillText(text, W()/2, y);
    ctx.textAlign = "left";
  }

  function drawOverlayText() {
    doodleStroke();
    ctx.font = `700 ${Math.max(18, Math.round(Math.min(W(),H())*0.03))}px ui-rounded, system-ui, -apple-system, sans-serif`;
    ctx.fillStyle = "#fff";
    ctx.strokeStyle = "#000";
    ctx.lineWidth = Math.max(3, Math.round(Math.min(W(),H())*0.004));

    const pad = 14;
    const scoreTxt = `★ ${Math.floor(world.score)}`;
    ctx.strokeText(scoreTxt, pad, pad + 22);
    ctx.fillText(scoreTxt, pad, pad + 22);

    if (world.state === "ready") {
      centerText("TOCCA PER SALTARE", H()*0.45, 1.15);
      centerText("prendi i bonus in alto • evita i buchi", H()*0.45 + 34, 0.75);
    }
    if (world.state === "over") {
      centerText("CADUTO!", H()*0.43, 1.2);
      centerText(`punteggio: ${Math.floor(world.score)}  |  best: ${world.best}`, H()*0.43 + 34, 0.8);
      centerText("tocca per ricominciare", H()*0.43 + 64, 0.75);
    }
  }

  function render() {
    drawBackground();
    for (const it of items) drawItem(it);
    drawPig();
    drawOverlayText();
  }

  function loop(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // ---------- Boot: carica immagini ----------
  (async () => {
    IMAGES.bg = await loadImage(ASSETS.bgSrc);
    IMAGES.bong = await loadImage(ASSETS.bongSrc);
    IMAGES.cuffs = await loadImage(ASSETS.cuffsSrc);

    reset();
    requestAnimationFrame(loop);
  })();

})();
</script>
</body>
</html>
